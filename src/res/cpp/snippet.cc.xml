<?xml version="1.1" encoding="UTF-8"?>
<tns:root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="invar.template ../snippet.xsd"
  xmlns:tns="invar.template" language="cpp">
  
  <!--
  <export resPath="/res/cpp/InvarReadData.cs" destDir="Invar" destName="InvarReadData.cs"/>
  <export resPath="/res/cpp/InvarRule.cs" destDir="Invar" destName="InvarRule.cs"/>
  -->

  <!-- Redefine 14 Invar buildin types to adapt C++ language  -->
  <redefine>
    <int8 pack="std" type="int8_t" initValue="-1"/>
    <int16 pack="std" type="int16_t" initValue="-1"/>
    <int32 pack="std" type="int32_t" initValue="-1"/>
    <int64 pack="std" type="int64_t" initValue="-1" initSuffix="L"/>
    <uint8 pack="std" type="uint8_t" initValue="0"/>
    <uint16 pack="std" type="uint16_t" initValue="0"/>
    <uint32 pack="std" type="uint32_t" initValue="0"/>
    <uint64 pack="std" type="uint64_t" initValue="0" initSuffix="L"/>
    <float pack="" type="float" initValue="0.0" initSuffix="F"/>
    <double pack="" type="double" initValue="0.00"/>
    <string pack="std" type="string" initValue="" initPrefix="&quot;" initSuffix="&quot;"/>
    <bool pack="std" type="bool" initValue="false"/>
    <vec pack="std" type="vector" generic="&lt;?&gt;" initValue=""/>
    <map pack="std" type="map" generic="&lt;?,?&gt;" initValue=""/>
  </redefine>
  
  <template key="pack.name.nested"><![CDATA[true]]></template>
  <template key="capitalize.pack.head"><![CDATA[false]]></template>
  <template key="code.dir.flatten"><![CDATA[true]]></template>
  <template key="method.indent.num"><![CDATA[0]]></template>
  <template key="one.pack.one.file"><![CDATA[false]]></template>
  
  <template key="file"><![CDATA[
	// THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
	(#blank)
	#ifndef _(#define)_H_
	#define _(#define)_H_
	(#blank)
	(#pack)
	(#blank)
	#endif //_(#define)_H_]]></template>
 
  <template key="file.pack"><![CDATA[
	namespace (#name) {
	(#body)
	} //namespace: (#name)]]></template>
  
  <template key="file.body"><![CDATA[
	(#blank)
	(#import)(#enums)(#structs)]]></template>
  
  
  
  
  <!-- Common snippet -->
  <template key="doc"><![CDATA[/* (#doc). */]]></template>
  <template key="doc.line"><![CDATA[// (#doc).]]></template>
  <template key="import"><![CDATA[using (#body);(#brk)]]></template>
  <template key="import.body"><![CDATA[(#pack)]]></template>
  <template key="import.split"><![CDATA[::]]></template>
  
  <template key="init.struct"><![CDATA[new (#type)()]]></template>
  <template key="init.enum"><![CDATA[(#type).(#name)]]></template>
  <template key="code.invoker"><![CDATA[.]]></template>
  <template key="code.assignment"><![CDATA[(#type)(#name) = (#value);]]></template>
  <template key="code.definition"><![CDATA[(#type) (#name);(#brk)]]></template>
  <template key="code.indexer"><![CDATA[ (#name)[(#index)] ]]></template>
  <template key="code.fori.itype"><![CDATA[int32]]></template>
  <template key="code.fori"><![CDATA[
  for ((#type) (#index) = 0; (#index) < (#len); (#index)++)
  {(#body)
  }
  ]]></template>
  <template key="code.foreach"><![CDATA[
  foreach ((#type) (#name) in (#nameupper))
  {(#body)
  }
  ]]></template>
  
  
  <template key="pack"><![CDATA[
   		// THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
   		(#import)
   		namespace (#name) {
	 		(#body)} // namespace (#name)
	]]></template>
  <template key="enum"><![CDATA[
	    (#brk)(#doc)
		public enum (#name) : int
		{
			(#body)
		} // enum (#name)
	]]></template>
  <template key="enum.field"><![CDATA[
		(#brk)(#tab)(#doc)
		(#tab)(#name) = (#value),
	]]></template>
  <template key="struct"><![CDATA[
		(#blank)
		(#name)::(#name)()
		{
		}
		(#blank)
		(#name)::~(#name)()
		{
		}
		(#blank)
		(#name)::(#name)(const (#name) &from)
		{
			(#tab)if (this != &from) { CopyFrom(from); }
		}
		(#blank)
		(#name)& (#name)::operator = (const (#name) &from)
		{
			(#tab)if (this != &from) { CopyFrom(from); }
			(#tab)return *this;
		}
		(#blank)
		(#name)& (#name)::CopyFrom(const (#name) &from)
		{
			(#tab)return *this;
		}
		(#blank)
		
		//(#copyfrom)
		
		(#getters)
		(#setters)
		
		(#encoder)
		(#decoder)
		
	]]></template>
  <template key="struct.meta"><![CDATA[ [Invar.InvarRule("(#type)", "(#name)")] ]]></template>
  <template key="struct.field"><![CDATA[
  (#tab) (#type) (#name) = (#value);(#doc)(#brk)]]></template>
  <template key="struct.setter"><![CDATA[
    	(#typehost)& (#typehost)::Set(#nameupper)((#type) value) { (#name) = value; return *this; }
	]]></template>
  <template key="struct.getter"><![CDATA[
    	const (#type) (#typehost)::Get(#nameupper)() const { return (#name); }
	]]></template>

  
  <!-- Read bytes from a Stream -->
  <template key="read.import"><![CDATA[System.IO]]></template>
  <template key="read.method"><![CDATA[
  (#type)& (#type)::Read(BinaryReader stream)
  {(#body)
  (#tab)return *this;
  }
  ]]></template>
  <template key="read.int8"><![CDATA[(#name) = stream.ReadSByte();]]></template>
  <template key="read.int16"><![CDATA[(#name) = stream.ReadInt16();]]></template>
  <template key="read.int32"><![CDATA[(#name) = stream.ReadInt32();]]></template>
  <template key="read.int64"><![CDATA[(#name) = stream.ReadInt64();]]></template>
  <template key="read.uint8"><![CDATA[(#name) = stream.ReadByte();]]></template>
  <template key="read.uint16"><![CDATA[(#name) = stream.ReadUInt16();]]></template>
  <template key="read.uint32"><![CDATA[(#name) = stream.ReadUInt32();]]></template>
  <template key="read.uint64"><![CDATA[(#name) = stream.ReadUInt64();]]></template>
  <template key="read.float"><![CDATA[(#name) = stream.ReadSingle();]]></template>
  <template key="read.double"><![CDATA[(#name) = stream.ReadDouble();]]></template>
  <template key="read.string"><![CDATA[(#name) = stream.ReadString();]]></template>
  <template key="read.bool"><![CDATA[(#name) = stream.ReadBoolean();]]></template>
  <template key="read.enum"><![CDATA[(#name) = ((#type))Enum.ToObject(typeof((#type)), stream.ReadInt32());]]></template>
  <template key="read.struct"><![CDATA[(#name).Read(stream);]]></template>
  <template key="read.struct.check"><![CDATA[
  if (stream.ReadByte() == 0x01)
  {
  (#tab)if ((#name) == null)
  (#tab)(#tab)(#name) = new (#type)();
  (#tab)(#name).Read(stream);
  }
  ]]></template>
  <template key="read.size.init"><![CDATA[stream.ReadInt32();]]></template>
  <template key="read.vec"><![CDATA[(#name).Add((#value));]]></template>
  <template key="read.map"><![CDATA[(#nameupper).Add((#name),(#value));]]></template>
  <template key="read.vec.for"><![CDATA[
  int32_t (#len) = stream.ReadInt32();
  for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++) //read.vec.for
  {(#body)
  (#tab)(#name).Add((#value));
  }
  ]]></template>
  <template key="read.map.keys"><![CDATA[]]></template>
  <template key="read.map.for"><![CDATA[
  int32_t (#len) = stream.ReadInt32();
  for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++) //read.map.for
  {(#body)
  (#tab)(#name).Add((#key),(#value));
  }
  ]]></template>
  
  
  <!-- Write bytes to a Stream -->
  <template key="write.import"><![CDATA[System.IO,System]]></template>
  <template key="write.method"><![CDATA[
  (#type)& (#type)::Write(BinaryWriter stream)
  {(#body)
  (#tab)return *this;
  }
  ]]></template>
  <template key="write.int8"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.int16"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.int32"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.int64"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.uint8"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.uint16"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.uint32"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.uint64"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.float"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.double"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.string"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.bool"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.enum"><![CDATA[stream.Write((Int32)(#name));]]></template>
  <template key="write.struct"><![CDATA[(#name).Write(stream);]]></template>
  <template key="write.struct.check"><![CDATA[
  if ((#name) != null)
  {
  (#tab)stream.Write((Byte)0x01);
  (#tab)(#name).Write(stream);
  }
  else
  {
  (#tab)stream.Write((Byte)0x00);
  }
  ]]></template>
  <template key="write.size.init"><![CDATA[(#name).Count]]></template>
  <template key="write.vec.for"><![CDATA[
  int32_t (#len) = (#name).Count;
  stream.Write((#len));
  for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++) //write.vec.for
  {(#body)
  }
  ]]></template>
  <template key="write.map.keys"><![CDATA[Keys]]></template>
  <template key="write.map.for"><![CDATA[
  int32_t (#len) = (#nameupper).Count;
  stream.Write((#len));
  foreach ((#type) (#name) in (#nameupper).Keys) //write.map.for
  {(#body)
  }
  ]]></template>
  
  
  
  <template key="runtime.pack"><![CDATA[Invar]]></template>
  <template key="runtime.name"><![CDATA[InvarRuntime]]></template>
  <template key="runtime.alias"><![CDATA[
    (#tab)static private Dictionary<String,Type> (#name) ()
    (#tab){
    (#tab)(#tab)Dictionary<String,Type> map = new Dictionary<String,Type>();(#body)
    (#tab)(#tab)return map;
    (#tab)}
	]]></template>
  <template key="runtime.alias.basic"><![CDATA[(#brk)(#tab)(#tab)map.Add("(#name)", typeof((#type)));]]></template>
  <template key="runtime.alias.list"><![CDATA[(#brk)(#tab)(#tab)map.Add("(#name)", typeof((#type)<>));]]></template>
  <template key="runtime.alias.map"><![CDATA[(#brk)(#tab)(#tab)map.Add("(#name)", typeof((#type)<,>));]]></template>
  <template key="runtime.body"><![CDATA[
    (#tab)static public InvarReadData MakeXmlReader ()
    (#tab){
    (#tab)(#tab)if (InvarReadData.AliasBasics == null) {
    (#tab)(#tab)(#tab)InvarReadData.AliasBasics = aliasBasic ();
    (#tab)(#tab)(#tab)InvarReadData.AliasEnums = aliasEnum ();
    (#tab)(#tab)(#tab)InvarReadData.AliasStructs = aliasStruct ();
    (#tab)(#tab)}
    (#tab)(#tab) return new InvarReadData ();
    (#tab)}
    (#body)
	]]></template>
  
  <!-- Output data to xml -->
  <template key="toxml.import"><![CDATA[System.Text]]></template>
  <template key="toxml.method"><![CDATA[
  (#tab)public (#type) ToXML(String nodeName)
  (#tab){
  (#tab)(#tab)StringBuilder code = new StringBuilder ();
  (#body)
  (#tab)(#tab)return code.ToString();
  (#tab)}
  ]]></template>
</tns:root>