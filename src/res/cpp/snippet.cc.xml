<?xml version="1.1" encoding="UTF-8"?>
<tns:root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="invar.template ../snippet.xsd"
  xmlns:tns="invar.template" language="cpp">
  <export resPath="/res/cpp/invar.codec.cpp" destDir="" destName="invar.codec.cpp"/>
  <redefine genericOverride="true"/>
  <template key="include.self"><![CDATA[true]]></template>
  <template key="pack.name.nested"><![CDATA[true]]></template>
  <template key="file.name.lowercase"><![CDATA[true]]></template>
  <template key="capitalize.pack.head"><![CDATA[false]]></template>
  <template key="method.indent.num"><![CDATA[0]]></template>
  <template key="one.pack.one.file"><![CDATA[false]]></template>
  <template key="code.dir.flatten"><![CDATA[true]]></template>
  <template key="code.dir.prefix"><![CDATA[impl/]]></template>
  <template key="refer.spec"><![CDATA[&]]></template>
  <template key="refer.invoke"><![CDATA[.]]></template>
  <template key="refer.const"><![CDATA[const]]></template>
  <template key="pointer.spec"><![CDATA[*]]></template>
  <template key="pointer.invoke"><![CDATA[->]]></template>
  <template key="pointer.null"><![CDATA[NULL]]></template>
  <template key="pointer.copy"><![CDATA[invar::CheckSet< (#type) > ((#name), (#value));]]></template>
  <template key="null.struct"><![CDATA[*((#type)*)NULL]]></template>
  <template key="null.byte.yes"><![CDATA[(std::int8_t)0x01]]></template>
  <template key="null.byte.no"><![CDATA[(std::int8_t)0x00]]></template>
  <template key="file"><![CDATA[
	(#blank)
	//===----------------------------*  CPP  *---------------------------------===//
	//
	//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
	//
	//===----------------------------------------------------------------------===//
	(#blank)
	#ifndef IMPL_(#define)_
	#define IMPL_(#define)_
	(#blank)
	(#includes)
	(#pack)
	(#blank)
	#endif //IMPL_(#define)_]]></template>
  <template key="file.include"><![CDATA[#include (#name)(#brk)]]></template>
  <template key="file.pack"><![CDATA[
	namespace (#name) { (#body)
	} //namespace: (#name)]]></template>
  <template key="file.body"><![CDATA[
	(#blank)
	(#blank)
	(#import)(#enums)(#structs)]]></template>
  
  
  <!-- Common snippet -->
  <template key="doc"><![CDATA[/* (#doc). */]]></template>
  <template key="doc.line"><![CDATA[// (#doc).]]></template>
  <template key="import"><![CDATA[using namespace (#body);(#brk)]]></template>
  <template key="import.body"><![CDATA[(#pack)]]></template>
  <template key="import.split"><![CDATA[::]]></template>
  <template key="init.struct"><![CDATA[]]></template>
  <template key="init.enum"><![CDATA[(#name)]]></template>
  <template key="code.invoker"><![CDATA[.]]></template>
  <template key="code.assignment"><![CDATA[(#type)(#name) = (#value);(#brk)]]></template>
  <template key="code.definition"><![CDATA[(#type)(#name);(#brk)]]></template>
  <template key="code.indexer"><![CDATA[ (#name)[(#index)] ]]></template>
  <template key="code.fori.itype"><![CDATA[int32]]></template>
  <template key="code.fori"><![CDATA[
  for ((#type) (#index) = 0; (#index) < (#len); (#index)++)
  {(#body)
  }
  ]]></template>
  <template key="code.foreach"><![CDATA[
  foreach ((#type) (#name) in (#nameupper))
  {(#body)
  }
  ]]></template>
  <template key="ctor"><![CDATA[]]></template>
  <template key="ctor.field"><![CDATA[(#tab)(#name)((#value))]]></template>
  <template key="ctor.field.split"><![CDATA[,(#brk)]]></template>
  <template key="struct"><![CDATA[
	(#blank)[#addImport(struct; imports; invar::BinaryReader)]
	(#name)::~(#name) ()
	{
	}
	(#blank)
	(#name)::(#name) ():
	[#codeInits(struct; fields)]
	{
	}
	(#blank)
	(#name)::(#name) (const (#name)& from)
	{
	(#tab)if (this != &from) {
	(#tab)(#tab)CopyFrom(from);
	(#tab)}
	}
	(#blank)
	(#name)& (#name)::operator = (const (#name)& from)
	{
		(#tab)if (this != &from) {
		(#tab)(#tab)CopyFrom(from);
		(#tab)}
		(#tab)return *this;
	}
	(#blank)
	[#operatorLess(struct)]
	(#blank)
	[#codeNested (copy.;  useFullName; struct; fields; imports)](#brk)
    [#codeNested (read.;  useFullName; struct; fields; imports)](#brk)
	[#codeNested (write.; useFullName; struct; fields; imports)](#brk)
	[#codeGetters(struct; fields)]
	[#codeSetters(struct; fields)]
  ]]></template>
  <template key="struct.meta"><![CDATA[ [Invar.InvarRule("(#type)", "(#name)")] ]]></template>
  <template key="struct.field.self"><![CDATA[&]]></template>
  <template key="struct.field"><![CDATA[
	(#tab) (#type) (#name) = (#value);(#doc)(#brk)]]></template>
  <template key="struct.setter"><![CDATA[
	(#typeupper)& (#typeupper)::Set[#upperHeadChar( (#name) )] ((#type) (#spec)value)
	{
	(#tab)(#name) = value;
	(#tab)return *this;
	}
  ]]></template>
  <template key="struct.getter"><![CDATA[
	(#type)(#spec)(#typeupper)::Get[#upperHeadChar( (#name) )] ()
	{
	(#tab)return (#name);
	}
  ]]></template>
  <template key="less.method"><![CDATA[
    bool (#type)::operator < (const (#type)& other) const
    {
    (#body)
    }]]></template>
  <template key="less.body.key"><![CDATA[(#tab)return key < other.key;]]></template>
  <template key="less.body.deft"><![CDATA[(#tab)return false;]]></template>

  <!-- CopyFrom Method -->
  <template key="copy.import"><![CDATA[]]></template>
  <template key="copy.method"><![CDATA[
    (#type)& (#type)::CopyFrom (const (#type) &from)
    {
      (#tab)if (this == &from) {
      (#tab)(#tab)return *this;
      (#tab)}(#body)
      (#tab)return *this;
    } //(#type)::CopyFrom(...)]]></template>
  <template key="copy.method.arg"><![CDATA[from]]></template>
  <template key="copy.int8">  <![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.int16"> <![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.int32"> <![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.int64"> <![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.uint8"> <![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.uint16"><![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.uint32"><![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.uint64"><![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.float"> <![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.double"><![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.string"><![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.bool">  <![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.enum">  <![CDATA[ (#spec)(#name) = (#spec)(#arg)(#split)(#name);  ]]></template>
  <template key="copy.struct"><![CDATA[ (#name)(#invoke)CopyFrom((#arg)(#split)(#name));]]></template>
  <template key="copy.struct.check"><![CDATA[
    if (from.(#name) != (#null)) {
      (#tab)if ((#name) == (#null)) {
      (#tab)(#tab)(#name) = new (#type)(*from.(#name));
      (#tab)}
    } else {
      (#tab)if ((#name) != (#null)) {
      (#tab)(#tab)delete (#name);
      (#tab)(#tab)(#name) = (#null);
      (#tab)}
    }
  ]]></template>
  <template key="copy.vec.field"><![CDATA[const (#type) &(#arg)_(#name) = (#spec)(#arg).(#name); //copy.vec.field(#brk)]]></template>
  <template key="copy.vec.nest"><![CDATA[(#type) &(#name) = (#nameupper)[(#index)];
    const (#type) &(#arg)_(#name) = (#arg)_(#nameupper)[(#index)]; //copy.vec.nest(#brk)]]></template>
  <template key="copy.vec.def.n"><![CDATA[const (#type) &(#name) = (#arg)_(#nameupper)[(#index)];(#brk)]]></template>
  <template key="copy.vec.for"><![CDATA[
    (#sizetype) (#len) = static_cast<(#sizetype)>((#arg)_(#name).size());
    (#name)(#invoke)reserve((#len));
    for ((#sizetype) (#index) = 0; (#index) < (#len); ++(#index)) {(#body)
    (#tab)(#name)(#invoke)push_back((#value));
    }
  ]]></template>
  <template key="copy.map.field"><![CDATA[const (#type) &(#arg)_(#name) = (#spec)(#arg).(#name);(#brk)]]></template>
  <template key="copy.map.nest"><![CDATA[(#type) (#name);
  	const (#type) &(#arg)_(#name) = (#value);
  ]]></template>
  <template key="copy.map.nest.k"><![CDATA[(#nameupper)Iter->first]]></template>
  <template key="copy.map.nest.v"><![CDATA[(#nameupper)Iter->second]]></template>
  <template key="copy.map.def.k"><![CDATA[const (#type) &(#name) = (#nameupper)Iter->first;(#brk)]]></template>
  <template key="copy.map.def.v"><![CDATA[const (#type) &(#name) = (#nameupper)Iter->second;(#brk)]]></template>
  <template key="copy.map.for"><![CDATA[
    (#name)(#invoke)clear();
    (#type)::const_iterator (#name)Iter = (#arg)_(#name).begin();
    (#type)::const_iterator (#name)IterEnd = (#arg)_(#name).end();
    while ((#name)Iter != (#name)IterEnd) {(#body)
    (#tab)(#name)(#invoke)insert((#type)::value_type((#key),(#value)));
    (#tab)++(#name)Iter;
    }
  ]]></template>

  
  <!-- Read bytes from a Stream -->
  <template key="read.import"><![CDATA[invar::BinaryReader]]></template>
  <template key="read.method"><![CDATA[
    (#type)& (#type)::Decode (BinaryReader &stream)
    {(#body)
    (#tab)return *this;
    } //(#type)::Decode(...)]]></template>
  <template key="read.method.arg"><![CDATA[stream]]></template>
  <template key="read.int8">  <![CDATA[ (#spec)(#name) = (#arg).ReadByte();    ]]></template>
  <template key="read.int16"> <![CDATA[ (#spec)(#name) = (#arg).ReadInt16();   ]]></template>
  <template key="read.int32"> <![CDATA[ (#spec)(#name) = (#arg).ReadInt32();   ]]></template>
  <template key="read.int64"> <![CDATA[ (#spec)(#name) = (#arg).ReadInt64();   ]]></template>
  <template key="read.uint8"> <![CDATA[ (#spec)(#name) = (#arg).ReadUByte();   ]]></template>
  <template key="read.uint16"><![CDATA[ (#spec)(#name) = (#arg).ReadUInt16();  ]]></template>
  <template key="read.uint32"><![CDATA[ (#spec)(#name) = (#arg).ReadUInt32();  ]]></template>
  <template key="read.uint64"><![CDATA[ (#spec)(#name) = (#arg).ReadUInt64();  ]]></template>
  <template key="read.float"> <![CDATA[ (#spec)(#name) = (#arg).ReadSingle();  ]]></template>
  <template key="read.double"><![CDATA[ (#spec)(#name) = (#arg).ReadDouble();  ]]></template>
  <template key="read.string"><![CDATA[ (#spec)(#name) = (#arg).ReadString();  ]]></template>
  <template key="read.bool">  <![CDATA[ (#spec)(#name) = (#arg).ReadBoolean(); ]]></template>
  <template key="read.enum">  <![CDATA[ (#spec)(#name) = static_cast<(#type)>((#arg).ReadInt32());]]></template>
  <template key="read.struct"><![CDATA[ (#name)(#invoke)Decode((#arg));]]></template>
  <template key="read.struct.check"><![CDATA[
  if (stream.ReadByte() == 0x01) {
	  (#tab)if ((#name) == (#null))
	  (#tab)(#tab)(#name) = new (#type)();
	  (#tab)(#name)->Decode((#arg));
  } else {
      (#tab)if ((#name) != (#null)) {
      (#tab)(#tab)delete (#name);
      (#tab)(#tab)(#name) = (#null);
      (#tab)}
  }
  ]]></template>
  <template key="read.vec.nest">  <![CDATA[(#type) &(#name) = (#nameupper)[(#index)];(#brk)]]></template>
  <template key="read.vec.iter.n"><![CDATA[((#specupper)(#nameupper))[(#index)] ]]></template>
  <template key="read.vec.for"><![CDATA[
    uint32_t (#len) = stream.ReadUInt32();
    (#name)(#invoke)resize((#len));
    for ((#sizetype) (#index) = 0; (#index) < (#len); ++(#index)) {(#body)
    }
  ]]></template>
  <template key="read.map.nest">  <![CDATA[(#type) (#name);(#brk)]]></template>
  <template key="read.map.def.k"> <![CDATA[(#type) (#name);(#brk)]]></template>
  <template key="read.map.def.v"> <![CDATA[(#type) (#name);(#brk)]]></template>
  <template key="read.map.iter.k"><![CDATA[(#key)]]></template>
  <template key="read.map.iter.v"><![CDATA[(#value)]]></template>
  <template key="read.map.for"><![CDATA[
    uint32_t (#len) = stream.ReadUInt32();
    (#name)(#invoke)clear();
    for ((#sizetype) (#index) = 0; (#index) < (#len); ++(#index)) {(#body)
    (#tab)(#name)(#invoke)insert((#type)::value_type((#key),(#value)));
    }
  ]]></template>
  
  <!-- Write bytes to a Stream -->
  <template key="write.import"><![CDATA[ invar::BinaryReader ]]></template>
  <template key="write.method"><![CDATA[ void (#type)::Encode (BinaryWriter &stream) const
    {(#body)(#brk)} //(#type)::Encode(...) ]]></template>
  <template key="write.method.arg"><![CDATA[stream]]></template>
  <template key="write.int8">  <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.int16"> <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.int32"> <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.int64"> <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.uint8"> <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.uint16"><![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.uint32"><![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.uint64"><![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.float"> <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.double"><![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.string"><![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.bool">  <![CDATA[ (#arg).Write((#spec)(#name)); ]]></template>
  <template key="write.enum">  <![CDATA[ (#arg).Write(static_cast<int32_t>((#spec)(#name))); ]]></template>
  <template key="write.struct"><![CDATA[ (#name)(#invoke)Encode((#arg)); ]]></template>
  <template key="write.struct.check"><![CDATA[
    if ((#name) != (#null)) {
      (#tab)stream.Write(static_cast<int8_t>(0x01));
      (#tab)(#name)(#invoke)Encode((#arg));
    } else {
      (#tab)stream.Write(static_cast<int8_t>(0x00));
    }
  ]]></template>
  <template key="write.vec.nest">  <![CDATA[ const (#type) &(#name) = *(#nameupper)Iter;(#brk) ]]></template>
  <template key="write.vec.iter.n"><![CDATA[ (*(#nameupper)Iter) ]]></template>
  <template key="write.vec.for"><![CDATA[
    stream.Write(static_cast<(#sizetype)>((#name)(#invoke)size()));
    (#type)::const_iterator (#name)Iter = (#name)(#invoke)begin();
    (#type)::const_iterator (#name)IterEnd = (#name)(#invoke)end();
    while ((#name)Iter != (#name)IterEnd) {(#body)
    (#tab)++(#name)Iter;
    }
  ]]></template>
  <template key="write.map.nest"><![CDATA[const (#type) &(#name) = (#value);(#brk)]]></template>
  <template key="write.map.nest.k"><![CDATA[(#nameupper)Iter->first]]></template>
  <template key="write.map.nest.v"><![CDATA[(#nameupper)Iter->second]]></template>
  <template key="write.map.iter.k"><![CDATA[(#nameupper)Iter->first]]></template>
  <template key="write.map.iter.v"><![CDATA[(#nameupper)Iter->second]]></template>
  <template key="write.map.for"><![CDATA[
    stream.Write(static_cast<(#sizetype)>((#name)(#invoke)size()));
    (#type)::const_iterator (#name)Iter = (#name)(#invoke)begin();
    (#type)::const_iterator (#name)IterEnd = (#name)(#invoke)end();
    while ((#name)Iter != (#name)IterEnd) {(#body)
    (#tab)++(#name)Iter;
    }
  ]]></template>
</tns:root>