<?xml version="1.1" encoding="UTF-8"?>
<tns:root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="invar.template ../snippet.xsd"
  xmlns:tns="invar.template" language="cpp">
  <redefine genericOverride="true"/>
  <template key="include.self"><![CDATA[true]]></template>
  <template key="pack.name.nested"><![CDATA[true]]></template>
  <template key="file.name.lowercase"><![CDATA[true]]></template>
  <template key="capitalize.pack.head"><![CDATA[false]]></template>
  <template key="method.indent.num"><![CDATA[0]]></template>
  <template key="one.pack.one.file"><![CDATA[false]]></template>
  <template key="code.dir.flatten"><![CDATA[true]]></template>
  <template key="code.dir.prefix"><![CDATA[impl/]]></template>
  <template key="refer.spec"><![CDATA[&]]></template>
  <template key="refer.invoke"><![CDATA[.]]></template>
  <template key="refer.const"><![CDATA[const]]></template>
  <template key="pointer.spec"><![CDATA[*]]></template>
  <template key="pointer.invoke"><![CDATA[->]]></template>
  <template key="pointer.null"><![CDATA[NULL]]></template>
  <template key="null.struct"><![CDATA[*((#type)*)NULL]]></template>
  <template key="null.byte.yes"><![CDATA[(std::int8_t)0x01]]></template>
  <template key="null.byte.no"><![CDATA[(std::int8_t)0x00]]></template>
  <template key="file"><![CDATA[
	(#blank)
	//===----------------------------*  CPP  *---------------------------------===//
	//
	//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
	//
	//===----------------------------------------------------------------------===//
	(#blank)
	#ifndef IMPL_(#define)_
	#define IMPL_(#define)_
	(#blank)
	(#includes)
	(#pack)
	(#blank)
	#endif //IMPL_(#define)_]]></template>
  <template key="file.include"><![CDATA[#include (#name)(#brk)]]></template>
  <template key="file.pack"><![CDATA[
	namespace (#name) { (#body)
	} //namespace: (#name)]]></template>
  <template key="file.body"><![CDATA[
	(#blank)
	(#blank)
	(#import)(#enums)(#structs)]]></template>
  
  
  
  
  <!-- Common snippet -->
  <template key="doc"><![CDATA[/* (#doc). */]]></template>
  <template key="doc.line"><![CDATA[// (#doc).]]></template>
  <template key="import"><![CDATA[using namespace (#body);(#brk)]]></template>
  <template key="import.body"><![CDATA[(#pack)]]></template>
  <template key="import.split"><![CDATA[::]]></template>
  <template key="init.struct"><![CDATA[]]></template>
  <template key="init.enum"><![CDATA[(#name)]]></template>
  <template key="code.invoker"><![CDATA[.]]></template>
  <template key="code.assignment"><![CDATA[(#type)(#name) = (#value);(#brk)]]></template>
  <template key="code.definition"><![CDATA[(#type)(#name);(#brk)]]></template>
  <template key="code.indexer"><![CDATA[ (#name)[(#index)] ]]></template>
  <template key="code.fori.itype"><![CDATA[int32]]></template>
  <template key="code.fori"><![CDATA[
  for ((#type) (#index) = 0; (#index) < (#len); (#index)++)
  {(#body)
  }
  ]]></template>
  <template key="code.foreach"><![CDATA[
  foreach ((#type) (#name) in (#nameupper))
  {(#body)
  }
  ]]></template>
  <template key="ctor"><![CDATA[]]></template>
  <template key="ctor.field"><![CDATA[(#name)((#value))]]></template>
  <template key="ctor.field.split"><![CDATA[,(#brk)]]></template>
  <template key="struct"><![CDATA[
	(#blank)
	(#name)::~(#name)()
	{
	}
	
	(#blank)
	(#name)::(#name)():
	(#ctor)
	{
	}
	
	(#blank)
	(#name)::(#name)(const (#name)& from)
	{
	(#tab)if (this != &from) { CopyFrom(from); }
	}
	
	(#blank)
	(#name)& (#name)::CopyFrom (const (#name)& from)
	{
		(#tab)if (this == &from) { return *this; }
		//TODO CopyFrom Implementation
		(#tab)return *this;
	}
	
	(#blank)
	(#name)& (#name)::operator = (const (#name)& from)
	{
		(#tab)if (this != &from) { CopyFrom(from); }
		(#tab)return *this;
	}
	
	(#blank)
	bool (#name)::operator < (const (#name)& other) const
	{
		//TODO operator < Implementation
		(#tab)return true;
	}
	
	(#blank)
	(#getters)
	(#setters)
	
	(#decoder)
	(#encoder)
	
  ]]></template>
  <template key="struct.meta"><![CDATA[ [Invar.InvarRule("(#type)", "(#name)")] ]]></template>
  <template key="struct.field.self"><![CDATA[&]]></template>
  <template key="struct.field"><![CDATA[
	(#tab) (#type) (#name) = (#value);(#doc)(#brk)]]></template>
  <template key="struct.setter"><![CDATA[
	(#typehost)& (#typehost)::Set(#nameupper)((#type) (#spec)value) { (#name) = value; return *this; }
  ]]></template>
  <template key="struct.getter"><![CDATA[
	(#type)(#spec) (#typehost)::Get(#nameupper)() { return (#name); }
  ]]></template>

  
  <!-- Read bytes from a Stream -->
  <template key="read.import"><![CDATA[invar::BinaryReader]]></template>
  <template key="read.method"><![CDATA[
  (#type)& (#type)::Decode(BinaryReader &stream)
  {(#body)
  (#tab)return *this;
  }
  ]]></template>
  <template key="read.int8"><![CDATA[stream.ReadSByte()]]></template>
  <template key="read.int16"><![CDATA[stream.ReadInt16()]]></template>
  <template key="read.int32"><![CDATA[stream.ReadInt32()]]></template>
  <template key="read.int64"><![CDATA[stream.ReadInt64()]]></template>
  <template key="read.uint8"><![CDATA[stream.ReadByte()]]></template>
  <template key="read.uint16"><![CDATA[stream.ReadUInt16()]]></template>
  <template key="read.uint32"><![CDATA[stream.ReadUInt32()]]></template>
  <template key="read.uint64"><![CDATA[stream.ReadUInt64()]]></template>
  <template key="read.float"><![CDATA[stream.ReadSingle()]]></template>
  <template key="read.double"><![CDATA[stream.ReadDouble()]]></template>
  <template key="read.string"><![CDATA[stream.ReadString()]]></template>
  <template key="read.bool"><![CDATA[stream.ReadBoolean()]]></template>
  <template key="read.enum"><![CDATA[((#type))stream.ReadInt32()]]></template>
  <template key="read.struct"><![CDATA[(#name)(#invoke)Decode(stream);]]></template>
  <template key="read.struct.check"><![CDATA[
  if (stream.ReadByte() == 0x01)
  {
	  (#tab)if ((#name) == (#value))
	  (#tab)(#tab)(#name) = new (#type)();
	  (#tab)(#name)->Decode(stream);
  }
  else
  {
      (#tab)if ((#name) != (#value))
      (#tab){
      (#tab)(#tab)delete (#name);
      (#tab)(#tab)(#name) = (#value);
      (#tab)}
  }
  ]]></template>
  <template key="read.size.init"><![CDATA[stream.ReadInt32();]]></template>
  <template key="read.vec"><![CDATA[(#name).Add((#value));]]></template>
  <template key="read.map"><![CDATA[(#nameupper).Add((#name),(#value));]]></template>
  <template key="read.vec.for"><![CDATA[
  int32_t (#len) = stream.ReadInt32();
  (#name).reserve((#len));
  for ((#sizetype) (#index) = 0; (#index) < (#len); ++(#index)) //read.vec.for
  {(#body)
  (#tab)(#name).push_back((#value));
  }
  ]]></template>
  <template key="read.map.keys"><![CDATA[]]></template>
  <template key="read.map.for"><![CDATA[
  int32_t (#len) = stream.ReadInt32();
  for ((#sizetype) (#index) = 0; (#index) < (#len); ++(#index)) //read.map.for
  {(#body)
  (#tab)(#name).insert((#type)::value_type((#key),(#value)));
  }
  ]]></template>
  
  
  <!-- Write bytes to a Stream -->
  <template key="write.import"><![CDATA[invar::BinaryReader]]></template>
  <template key="write.method"><![CDATA[
  void (#type)::Encode(BinaryWriter &stream) const
  {(#body)
  }
  ]]></template>
  <template key="write.err.check"><![CDATA[if (stream.HasError()) { stream.OnError("(#name)"); return *this;}]]></template>
  <template key="write.int8"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.int16"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.int32"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.int64"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.uint8"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.uint16"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.uint32"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.uint64"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.float"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.double"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.string"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.bool"><![CDATA[stream.Write((#name));]]></template>
  <template key="write.enum"><![CDATA[stream.Write((int32_t)(#name));]]></template>
  <template key="write.struct"><![CDATA[(#name)(#invoke)Encode(stream);]]></template>
  <template key="write.struct.check"><![CDATA[
  if ((#name) != (#value))
  {
  (#tab)stream.Write((std::int8_t)0x01);
  (#tab)(#name)(#invoke)Encode(stream);
  }
  else
  {
  (#tab)stream.Write((std::int8_t)0x00);
  }
  ]]></template>
  <template key="write.vec.iter.v"><![CDATA[(*(#name)Iter)]]></template>
  <template key="write.map.iter.k"><![CDATA[(#name)Iter->first]]></template>
  <template key="write.map.iter.v"><![CDATA[(#name)Iter->second]]></template>
  <template key="write.size.init"><![CDATA[(#name).Count]]></template>
  <template key="write.vec.for"><![CDATA[
    int32_t (#len) = (#name).size();
    stream.Write((#len));
    (#type)::const_iterator (#name)Iter = (#name).begin();
    (#type)::const_iterator (#name)IterEnd = (#name).end();
    while ((#name)Iter != (#name)IterEnd) // write.vec.iter (#name)
    {(#body)
    (#tab)++(#name)Iter;
    }
  ]]></template>
  <template key="write.vec.for2"><![CDATA[
  int32_t (#len) = (#name).size();
  stream.Write((#len));
  for ((#sizetype) (#index) = 0; (#index) < (#len); (#index)++) //write.vec.for
  {(#body)
  }
  ]]></template>
  
  <template key="write.map.for"><![CDATA[
    (#blank)
    int32_t (#len) = (#name).size();
    stream.Write((#len));
    (#type)::const_iterator (#name)Iter = (#name).begin();
    (#type)::const_iterator (#name)IterEnd = (#name).end();
    while ((#name)Iter != (#name)IterEnd) // write.map.iter (#name)
    {(#body)
    (#tab)++(#name)Iter;
    }
  ]]></template>
  
  <template key="write.map.for2"><![CDATA[
	(#blank)
	int32_t (#len) = (#nameupper).size();
	stream.Write((#len));
	(#typeupper)::iterator (#nameupper)Iter;
	for ((#nameupper)Iter = (#nameupper).begin(); (#nameupper)Iter != (#nameupper).end(); ++(#nameupper)Iter) //write.map.for
	{(#body)
	}
  ]]></template>
  
  <!-- Output data to xml -->
  <template key="toxml.import"><![CDATA[]]></template>
  <template key="toxml.method"><![CDATA[
  (#tab)public (#type) ToXML(String nodeName)
  (#tab){
  (#tab)(#tab)StringBuilder code = new StringBuilder ();
  (#body)
  (#tab)(#tab)return code.ToString();
  (#tab)}
  ]]></template>
</tns:root>