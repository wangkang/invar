<?xml version="1.1" encoding="UTF-8"?>
<tns:root xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="invar.template ../snippet.xsd"
  xmlns:tns="invar.template" language="cpp">
  <export resPath="/res/cpp/invar.codec.h" destDir="" destName="invar.codec.h"/>
  <redefine>
    <int8 pack="std" type="int8_t" include="&lt;cstdint&gt;" initValue="-1"/>
    <int16 pack="std" type="int16_t" include="&lt;cstdint&gt;" initValue="-1"/>
    <int32 pack="std" type="int32_t" include="&lt;cstdint&gt;" initValue="-1"/>
    <int64 pack="std" type="int64_t" include="&lt;cstdint&gt;" initValue="-1"/>
    <uint8 pack="std" type="uint8_t" include="&lt;cstdint&gt;" initValue="0"/>
    <uint16 pack="std" type="uint16_t" include="&lt;cstdint&gt;" initValue="0"/>
    <uint32 pack="std" type="uint32_t" include="&lt;cstdint&gt;" initValue="0"/>
    <uint64 pack="std" type="uint64_t" include="&lt;cstdint&gt;" initValue="0"/>
    <string pack="std" type="string" include="&lt;string&gt;" initValue="&quot;&quot;" initPrefix="&quot;"
      initSuffix="&quot;"/>
    <float pack="" type="float" initValue="0.0" initSuffix="F"/>
    <double pack="" type="double" initValue="0.00"/>
    <bool pack="" type="bool" initValue="false"/>
    <vec pack="std" type="vector" generic="&lt; ? &gt;" include="&lt;vector&gt;"/>
    <map pack="std" type="map" generic="&lt; ?, ? &gt;" include="&lt;map&gt;"/>
    <dialect pack="std" type="size_t" include="&lt;cstddef&gt;"/>
    <dialect pack="invar" type="BinaryWriter" include="&quot;invar.codec.h&quot;"/>
    <dialect pack="invar" type="BinaryReader" include="&quot;invar.codec.h&quot;"/>
  </redefine>
  <template key="trace.all.types">     <![CDATA[false]]></template>
  <template key="include.self">        <![CDATA[false]]></template>
  <template key="pack.name.nested">    <![CDATA[true]]></template>
  <template key="file.name.lowercase"> <![CDATA[true]]></template>
  <template key="capitalize.pack.head"><![CDATA[false]]></template>
  <template key="method.indent.num">   <![CDATA[0]]></template>
  <template key="use.full.type.name">  <![CDATA[true]]></template>
  <template key="one.pack.one.file">   <![CDATA[false]]></template>
  <template key="code.dir.flatten">    <![CDATA[true]]></template>
  <template key="code.dir.prefix">     <![CDATA[include/]]></template>
  <template key="file"><![CDATA[
	//===----------------------------*  C++  *---------------------------------===//
	//
	//             THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
	//
	//===----------------------------------------------------------------------===//
	(#blank)
	#ifndef (#define)_
	#define (#define)_
	(#blank)
	(#includes)
	(#pack)
	(#blank)
	#endif //(#define)_
  ]]></template>
  <template key="file.include"><![CDATA[#include (#name)(#brk)]]></template>
  <template key="file.pack"><![CDATA[
	namespace (#name) {
	(#body)
	}; //namespace: (#name)]]></template>
  <template key="file.body"><![CDATA[
	(#enums)(#structs)]]></template>
  <template key="enum"><![CDATA[
	(#brk)(#doc)
	enum (#name)
	{
		(#blank)
		(#body)
	}; //enum: (#name)
  ]]></template>
  <template key="enum.field"><![CDATA[
	(#tab)(#name) = (#value),(#doc)
  ]]></template>
  <template key="struct"><![CDATA[
    (#brk)(#doc)
	class (#name) {
	[#addImport(struct; imports; invar::BinaryReader)]
    [#addImport(struct; imports; std::string)]
	(#concat)
    (#space)(#space)public:
	(#blank)
	(#space)(#space)(#space)~(#name) ();
	(#tab)(#blank) (#name) ();
	(#tab)(#name) (const (#name) &from);
    (#blank)
    (#tab)[#clampLen([#mathMax(8;lenStruct)]; 24; bool    )]   operator <  (const (#name) &other) const;
	(#tab)[#clampLen([#mathMax(8;lenStruct)]; 24; (#name) )] & operator =  (const (#name) &from);	
    (#tab)[#clampLen([#mathMax(8;lenStruct)]; 24; (#name) )] & CopyFrom    (const (#name) &from);
	(#tab)[#clampLen([#mathMax(8;lenStruct)]; 24; (#name) )] & Decode      (invar::BinaryReader &stream);
	(#tab)[#clampLen([#mathMax(8;lenStruct)]; 24; void    )]   Encode      (invar::BinaryWriter &stream) const;
    (#tab)[#clampLen([#mathMax(8;lenStruct)]; 24; void    )]   ToXmlString (const std::string &name, std::string &result) const;
	(#blank)
	[#codeGetters(struct; fields)]
	[#codeSetters(struct; fields)]
	(#space)(#space)private:
	(#blank)
	[#codeFields(struct; fields)]
	}; //class: (#name)
  ]]></template>
  <template key="struct.meta"><![CDATA[]]></template>
  <template key="struct.field"><![CDATA[
    (#tab)[#clampLen(lenFieldType; 64; (#type))] (#spec)
	(#concat) [#clampLen(lenFieldName; 16; (#name))];(#docline)
  ]]></template>
  <template key="struct.setter"><![CDATA[
    (#tab)(#typeupper) & Set[#clampLen(lenFieldName; 16; [#upperHeadChar( (#name) )] )] ((#const)(#type) (#spec));
  ]]></template>
  <template key="struct.getter"><![CDATA[
    (#tab)[#clampLen(lenFieldType; 64; (#const)(#type) )] (#spec)
    (#concat) Get[#clampLen(lenFieldName; 16; [#upperHeadChar( (#name) )] )]
    (#concat) (void);(#docline)
  ]]></template>
  
  <!-- Common snippet -->
  <template key="doc">           <![CDATA[/* (#doc) */]]></template>
  <template key="doc.line">      <![CDATA[(#space)//(#doc)]]></template>
  <template key="import">        <![CDATA[using namespace (#body);(#brk)]]></template>
  <template key="import.body">   <![CDATA[(#pack)]]></template>
  <template key="import.split">  <![CDATA[::]]></template>
  <template key="init.struct">   <![CDATA[]]></template>
  <template key="init.enum">     <![CDATA[(#name)]]></template>
  <template key="refer.spec">    <![CDATA[&]]>    </template>
  <template key="refer.invoke">  <![CDATA[.]]>    </template>
  <template key="refer.const">   <![CDATA[const]]></template>
  <template key="pointer.spec">  <![CDATA[*]]>    </template>
  <template key="pointer.invoke"><![CDATA[->]]>   </template>
  <template key="pointer.null">  <![CDATA[NULL]]> </template>
  <template key="type.enum">     <![CDATA[int32]]></template>
  <template key="null.byte.yes"> <![CDATA[(std::int8_t)0x01]]></template>
  <template key="null.byte.no">  <![CDATA[(std::int8_t)0x00]]></template>
</tns:root>