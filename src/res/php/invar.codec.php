<?php
// ===----------------------------* PHP 5 *-------------------------------===//
//
// THIS FILE IS GENERATED BY INVAR. DO NOT EDIT !!!
//
// ===----------------------------------------------------------------------===//
namespace invar;

final class BinaryWriter {
	static public function writeInt08($v, &$bytes) {
		$bytes .= pack ( 'c', $v );
	}
	static public function writeInt16($v, &$bytes) {
		$bytes .= pack ( 'v', $v ); // big endian 'n'
	}
	static public function writeInt32($v, &$bytes) {
		$bytes .= pack ( 'V', $v ); // big endian 'N'
	}
	static public function writeInt64($v, &$bytes) {
		$bytes .= pack ( 'VV', $v, 0x00000000 );
	}
	static public function writeUInt08($v, &$bytes) {
		$bytes .= pack ( 'c', $v );
	}
	static public function writeUInt16($v, &$bytes) {
		$bytes .= pack ( 'v', $v );
	}
	static public function writeUInt32($v, &$bytes) {
		$bytes .= pack ( 'V', $v );
	}
	static public function writeUInt64($v, &$bytes) {
		$bytes .= pack ( 'VV', $v, 0x00000000 );
	}
	static public function writeFloat32($v, &$bytes) {
		$bytes .= pack ( 'f', $v );
	}
	static public function writeFloat64($v, &$bytes) {
		$bytes .= pack ( 'd', $v );
	}
	static public function writeBoolean($v, &$bytes) {
		$bytes .= ($v == TRUE) ? "\x01" : "\x00";
	}
	static public function writeUTF($v, &$bytes) {
		$bytes .= pack ( 'VA*', strlen ( $v ), $v );
	}
}
final class BinaryReader {
	private $data = NULL;
	private $bytes = NULL;
	private $bytesPos = 1;
	private $bytesLen = 0;
	function __construct(&$data) {
		// $data The packed data.
		$this->data = $data;
		$this->bytes = unpack ( "C*", $data ); // index begin from 1.
		$this->bytesLen = count ( $this->bytes );
	}
	function __destruct() {
		// print "Destroying DataInput...\n";
		$this->bytes = NULL;
		$this->bytesLen = 0;
		$this->bytesPos = 1;
	}
	function checkAvailable($offset) {
		if ($this->bytesPos + $offset > $this->bytesLen + 1) {
			throw new \Exception ( 'EOF Error' );
		}
	}
	public function readInt08() {
		$this->checkAvailable ( 1 );
		$bits = $this->bytes [$this->bytesPos];
		$sign = ($bits >> 7) == 0 ? 1 : - 1;
		$this->bytesPos ++;
		return (~ ($bits - 1)) * $sign;
	}
	public function readInt16() {
		$this->checkAvailable ( 2 );
		$b1 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b2 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$sign = ($b2 >> 7) == 0 ? 1 : - 1;
		$bits = ($b2 << 8) | $b1;
		return (~ ($bits - 1)) * $sign;
	}
	public function readInt32() {
		$this->checkAvailable ( 4 );
		$b1 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b2 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b3 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b4 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$sign = ($b4 >> 7) == 0 ? 1 : - 1;
		$bits = ($b4 << 24) | ($b3 << 16) | ($b2 << 8) | $b1;
		return (~ ($bits - 1)) * $sign;
	}
	public function readInt64() {
		$this->checkAvailable ( 8 );
		$i = 0;
		$result = '';
		while ( $i < 8 ) {
			$bi = $this->bytes [$this->bytesPos];
			$this->bytesPos ++;
			$result .= dechex ( $bi );
			++ $i;
		}
		return $result;
	}
	public function readUInt08() {
		$this->checkAvailable ( 1 );
		$result = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		return $result;
	}
	public function readUInt16() {
		$this->checkAvailable ( 2 );
		$b1 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b2 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		return ($b2 << 8) | $b1;
	}
	public function readUInt32() {
		$this->checkAvailable ( 4 );
		$b1 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b2 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b3 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		$b4 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		return ($b4 << 24) | ($b3 << 16) | ($b2 << 8) | $b1;
	}
	public function readUInt64() {
		$this->checkAvailable ( 8 );
		$result = '';
		$i = 0;
		while ( $i < 8 ) {
			$bi = $this->bytes [$this->bytesPos];
			$this->bytesPos ++;
			$result .= dechex ( $bi );
			++ $i;
		}
		return $result;
	}
	public function readBoolean() {
		$this->checkAvailable ( 1 );
		$b1 = $this->bytes [$this->bytesPos];
		$this->bytesPos ++;
		return $b1 == 0 ? FALSE : TRUE;
	}
	public function readFloat32() {
		/* s（sign）；e（exponent）；m （mantissa） */
		$bits = $this->readInt32 ();
		$s = ($bits >> 31) == 0 ? 1 : - 1;
		$e = ($bits >> 23) & 0xff;
		$m = ($e == 0) ? ($bits & 0x007fffff) << 1 : ($bits & 0x007fffff) | 0x800000;
		return $s * $m * pow ( 2, $e - 150 );
	}
	public function readFloat64() {
		return $this->readInt64 ();
	}
	public function readUTF() {
		$len = $this->readInt32 ();
		$this->checkAvailable ( $len );
		$s = substr ( $this->data, $this->bytesPos - 1, $len );
		$a = unpack ( 'A*', $s );
		$this->bytesPos += $len;
		return $a [1];
	}
}
